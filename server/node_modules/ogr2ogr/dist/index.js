"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const archiver_1 = __importDefault(require("archiver"));
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const stream_1 = require("stream");
// Known /vsistdout/ support.
const stdoutRe = /csv|geojson|georss|gml|gmt|gpx|jml|kml|mapml|pdf|vdv/i;
const vsiStdIn = '/vsistdin/';
const vsiStdOut = '/vsistdout/';
let uniq = Date.now();
class Ogr2ogr {
    constructor(input, opts = {}) {
        var _a, _b, _c;
        this.inputPath = vsiStdIn;
        this.outputFormat = (_a = opts.format) !== null && _a !== void 0 ? _a : 'GeoJSON';
        this.customCommand = opts.command;
        this.customOptions = opts.options;
        this.customDestination = opts.destination;
        this.customEnv = opts.env;
        this.timeout = (_b = opts.timeout) !== null && _b !== void 0 ? _b : 0;
        this.maxBuffer = (_c = opts.maxBuffer) !== null && _c !== void 0 ? _c : 1024 * 1024 * 50;
        let { path, ext } = this.newOutputPath(this.outputFormat);
        this.outputPath = path;
        this.outputExt = ext;
        if (input instanceof stream_1.Readable) {
            this.inputStream = input;
        }
        else if (typeof input === 'string') {
            this.inputPath = this.newInputPath(input);
        }
        else {
            this.inputStream = stream_1.Readable.from([JSON.stringify(input)]);
        }
    }
    exec(cb) {
        this.run()
            .then((res) => cb(null, res))
            .catch((err) => cb(err));
    }
    then(onfulfilled, onrejected) {
        return this.run().then(onfulfilled, onrejected);
    }
    newInputPath(p) {
        let path = '';
        let ext = path_1.extname(p);
        switch (ext) {
            case '.zip':
            case '.kmz':
            case '.shz':
                path = '/vsizip/';
                break;
            case '.gz':
                path = '/vsigzip/';
                break;
            case '.tar':
                path = '/vsitar/';
                break;
        }
        if (/^(http|ftp)/.test(p)) {
            path += '/vsicurl/' + p;
            return path;
        }
        path += p;
        return path;
    }
    newOutputPath(f) {
        let ext = '.' + f.toLowerCase();
        if (stdoutRe.test(this.outputFormat)) {
            return { path: vsiStdOut, ext };
        }
        let path = path_1.join(os_1.tmpdir(), '/ogr_' + uniq++);
        switch (f.toLowerCase()) {
            case 'esri shapefile':
                path += '.shz';
                ext = '.shz';
                break;
            case 'mapinfo file':
            case 'flatgeobuf':
                ext = '.zip';
                break;
            default:
                path += ext;
        }
        return { path, ext };
    }
    createZipStream(p) {
        let archive = archiver_1.default('zip');
        archive.directory(p, false);
        archive.on('error', console.error);
        archive.finalize();
        return archive;
    }
    async run() {
        var _a;
        let command = (_a = this.customCommand) !== null && _a !== void 0 ? _a : 'ogr2ogr';
        let args = [
            '-f',
            this.outputFormat,
            '-skipfailures',
            this.customDestination || this.outputPath,
            this.inputPath,
        ];
        if (this.customOptions)
            args.push(...this.customOptions);
        let env = this.customEnv ? { ...process.env, ...this.customEnv } : undefined;
        let { stdout, stderr } = await new Promise((res, rej) => {
            let proc = child_process_1.execFile(command, args, { env, timeout: this.timeout, maxBuffer: this.maxBuffer }, (err, stdout, stderr) => {
                if (err)
                    rej(err);
                res({ stdout, stderr });
            });
            if (this.inputStream && proc.stdin)
                this.inputStream.pipe(proc.stdin);
        });
        let res = {
            cmd: command + args.join(' '),
            text: stdout,
            details: stderr,
            extname: this.outputExt,
        };
        if (/^geojson$/i.test(this.outputFormat)) {
            try {
                res.data = JSON.parse(stdout);
            }
            catch (err) {
                // ignore error
            }
        }
        if (!this.customDestination && this.outputPath !== vsiStdOut) {
            if (this.outputExt === '.zip') {
                res.stream = this.createZipStream(this.outputPath);
            }
            else {
                res.stream = fs_1.createReadStream(this.outputPath);
            }
        }
        return res;
    }
}
function ogr2ogr(input, opts) {
    return new Ogr2ogr(input, opts);
}
exports.default = ogr2ogr;
